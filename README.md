### 代码风格指南

[代码风格指南](https://angular.cn/guide/styleguide)

### 请求生命周期大致如下：

1. 收到请求
2. 全局绑定的中间件
3. 模块绑定的中间件
4. 全局守卫
5. 控制层守卫
6. 路由守卫
7. 全局拦截器（控制器之前）
8. 控制器层拦截器 （控制器之前）
9. 路由拦截器 （控制器之前）
10. 全局管道
11. 控制器管道
12. 路由管道 [FAQ](https://docs.nestjs.cn/7/faq)
13. 路由参数管道
14. 控制器（方法处理器） 15。服务（如果有）
15. 路由拦截器（请求之后）
16. 控制器拦截器 （请求之后）
17. 全局拦截器 （请求之后）
18. 异常过滤器 （路由，之后是控制器，之后是全局）
19. 服务器响应

# [FAQ](https://docs.nestjs.cn/7/faq)

1. 过滤器
> 过滤器是唯一一个不按照全局第一顺序执行的组件。而是会从最低层次开始处理，也就是说先从任何路由绑定的过滤器开始，然后是控制器层，最后才是全局过滤器。注意，异常无法从过滤器传递到另一个过滤器；如果一个路由层过滤器捕捉到一个异常，一个控制器或者全局层面的过滤器就捕捉不到这个异常。如果要实现类似的效果可以在过滤器之间使用继承。

2. 拦截器

> 拦截器在大部分情况下和守卫类似。只有一种情况例外：当拦截器返回的是一个RxJS Observables时，observables是以先进后出的顺序执行的。因此，入站请求是按照标准的全局、控制器和路由层次执行的，但请求的响应侧（例如，当从一个控制器方法的处理器返回时）则是从路由到控制器再到全局。另外，由管道、控制器或者服务抛出的任何错误都可以在拦截器的catchError操作者中被读取。

3. 全局路由前缀

```javascript
const app = await NestFactory.create(ApplicationModule);
app.setGlobalPrefix('v1');
```
